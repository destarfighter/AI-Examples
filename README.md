# DeStarfighter-AI-Examples
This repository will be continously updated with AI work-samples and fun projects. Feel free to come back later and take a look!

#### Current State
So far i am designing the structure of the code projects. Most AI work-samples will be in separate projects in the same solution(Graphical-AI-Solutions.sln), 
sharing common code through a DLL and tested through a solution-wide Unit-Test project. C/C++ will be the programming language used 
for all implementations. 

The solution-process and results will be displayed with a graphical compontent from SFML (https://www.sfml-dev.org/index.php)


## Pathfinding Project

#### Description:
The Project in development at the moment will explore the basics of path-finding and path-following in a 2d-sapce as well as some State-Based Behavior. 
When starting the application a map and a ai-character is created. 
 - The map gets a randomly generated set of walls and a target tile.
 - The ai-character uses a A* pathfinder to determine the shortest path from it's current position to the target.
 - A animation displaying the pathfinders search-steps is shown.
 - The ai-character walks from its current position to the target position.
 - The ai-character displays wether or not a path was found by setting it's animation to either 'celebrate' if successfull or 'cry' if not.
 - Then a new maze gets generated and the process starts over.
 
## Key Components
 
#### Pathfinder:
A class that contains the function 'getPath' which recieves a representation of map, start position and target position as arguments. It uses a A* algorithm with a manhattan-distance heuristic function to determine the shortest path from current position to target, returned as a vector of integers. 
 
#### ProblemSolver:
The "ai-character" which is tasked to find the shortest path from it's current position to a target position and walk to target position. The ProblemSolver contains a animationSprite component to display and manage animation-changes and a aiController that manages the states for the character.

#### ProblemSolverStates:
A Finite State Machine is used to manage the different states for the ProblemSolver. it uses a AIController component to manage all states with a AIState base-class to decouple the behaviors. The states for the ProblemSolver is the following:
- FindPathState - Makes an asynchronized call to Pathfinder.getPath and checks each update if a path has been found. When the pathfinder is ready it changes state.
- DrawPathProcessState - Animates the A* pathfinder search process in two steps. first it animates the tiles the algorithm investigated/visited by drawing a colored tile at a      specified frame rate. Then it draws the path using the same principle. 
- FollowPathState - Using a pointer to the ProblemSolver's animation component, it moves the character along the path generated by the pathfinder. at the meantime it updates      the characters walkcycle-animation to one of four directions matching the current movement direction.
- ShowResultState - Depending on the result from pathfinder's success or failure, one of two animation's is played. 'celebrate' animation if successfull or 'cry' animation if      not. The result is displayed for 3 seconds and then a new FindPathState is initialized.  
 
 
#### WorldState:
The state of all objects that should be drawn and or updated is managed through a Service Locator. WorldState provides a global point of access to the service without coupling users to the concrete class that implements it. Some of the services that WorldState provides is the following:
- AddNewObject - Adds a new object with the common base class 'WorldObject'
- RemoveObject - Removes a specified object from all containers in WorldState
- GetAllDrawableObjects - Returns the full list of Drawable Objects. (used by render-loop)
- GetAllUpdatableObjects - Returns the full list of Updatable Objects. (used by update-loop)
- GetObject - Returns a specific 'WorldObject' specified by a object-id. (used for global communication between objects)

